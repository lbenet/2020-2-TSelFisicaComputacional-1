
# Tarea 2




> Envío inicial del PR: **27 de marzo**.
>
> Aceptación PR *final*: **3 de abril**.

**NOTA**: Esta tarea incluye generar varias imágenes; no es necesario que las incluyan en su entrega, pero sí debe ser posible generarlas a partir de lo que entreguen.

## Ejercicio 1

Describan la dinámica de varias órbitas para los siguientes mapeos, usando distintos colores para distintas órbitas, en una misma gráfica. Interesa entre otras cosas saber cuántos puntos fijos tiene el mapeo y cómo es la dinámica cerca de dichos puntos.

(a) $M_1(x) = \frac{1}{3x}$.

(b) $M_2(x) = -\frac{x^5}{5}$.

(c) $M_3(x) = \frac{x}{2}-2$.

(d) $M_4(x) = x-x^2$.

```julia
using  Plots
```

```julia
#Utilizaré las funciones definidas en los ejercicios de la clase de mapeos:

"""
    itera_mapeo(f, x0, n)

    Iterates a function, n times
    
    Arguments:
    f -- function wich define the rule to iterate
    x0 -- a scalar, initial condition
    n -- int, iteration number
    
    Returns:
    its -- an array (vector) containing all the iterations sequences
    its_x -- an array (vector) containing all the domain values iterated
    its_y -- an array (vector) containing all the iteration values
    '''
"""
function itera_mapeo(f, x0, n::Int)
    x0 = x0
    x1 = f(x0)
    its = [x0,x1]
    its_x = [x0,x1]
    its_y = [x1,x1]
    for i in 1:n-1
        x0 = x1
        x1 = f(x1)
        push!(its, x1)
        push!(its_x,x0,x1)
        push!(its_y,x1,x1)
    end
    return its, its_x, its_y
end

"""
    analisis_grafico(F::Function, x0::Float64, n::Int)
    analisis_grafico(F::Function, x0::Float64, n::Int, domx=0.0:1/128:1.0)
    
    Realiza la gráfica de la función F, de la órbita generada a partir de esta y de la función identidad.

    Argumentos:
    f -- función que define la regla de iteración
    x0 -- Escalar, condicipon inicial
    n -- entero, número de iteraciones
    domx -- (opcional) StepRangeLen, define el domino para la gráfica de F y de la identidad

    Salida:
    Gráfico

"""
function analisis_grafico(F::Function, x0::Float64, n::Int, domx=0.0:1/128:1.0, ylimits = (0,1); color = :orange)
    its, its_x, its_y = itera_mapeo(F,x0,n)
    
    if ylimits == (0,1)
        ylimits = (minimum(its_y)-0.1, maximum(its_y)+0.1)
    end
    
    plot(vcat(x0,its_x), vcat(0.0,its_y), line=(color, :dash, 2.0),
            xaxis=("x"), 
            yaxis=("F(x)", ylimits), 
            legend=false, grid=false)

    scatter!(its_x, its_y, color=color, markersize=2) # Dibuja los puntos
    
    plot!(domx, F)# Dibuja F(x)

    plot!(domx, x->x, color=:red) # Dibuja f(x)=x
    plot!(domx, x->0.0, line = (:black, :dash, 1.0)) # Dibuja f(x)=0
end

"""
    analisis_grafico!(F::Function, x0::Float64, n::Int)

    Agrega a una figura la gráfica de una órbita de n iteracions generada a partir de la función F
    
    Argumentos: 
    F -- Función, regla de iteración
    x0 -- Flotante, condición inicial
    n -- Entero, número de iteraciones

"""
function analisis_grafico!(F::Function, x0::Float64, n::Int; color= :blue)
    its, its_x, its_y = itera_mapeo(F,x0,n)
    plot!(vcat(x0,its_x), vcat(0.0,its_y), line=(color, :dash, 2.0))
    scatter!(its_x, its_y, color=color, markersize=2) # Dibuja los puntos
end
```

```julia
#a)
M₁(x) = 1/(3x)
analisis_grafico(M₁,0.15,2,0.1:1/128:2.4, (0,2.5))
analisis_grafico!(M₁,0.18,2)
analisis_grafico!(M₁,0.3,2, color = :brown)
analisis_grafico!(M₁,0.7,2, color = :green)
analisis_grafico!(M₁,0.9,2, color = :red)

#Puede notarse que esta expresión no tiene puntos fijos. Las órbitas son cerradas
# y las iteraciones son periódicas
```

```julia
#b)
M₂(x) = -(x^5)/5
n = 3
analisis_grafico(M₂,-1.0, n ,-1.05:1/128:1.05,(-0.3,0.25))
analisis_grafico!(M₂,1.0,n)
analisis_grafico!(M₂,-0.9 ,n, color = :red)
analisis_grafico!(M₂,-0.75 ,n, color = :pink4)
analisis_grafico!(M₂,0.9 ,n, color = :gold)
analisis_grafico!(M₂,0.7 ,n, color = :green1)

#Esta expresión tiene un solo punto fijo en x0=0 al cual las órbitas se van acercando mientras oscilan,
#alrededor de él
```

```julia
#c)
M₃(x) = (x/2) - 2
n = 6
analisis_grafico(M₃,-8.0, n, -8.2:1/60:3.4,(-6.5,1.0))
analisis_grafico!(M₃,3.0, n)
analisis_grafico!(M₃,1.0 ,n, color = :red3)
analisis_grafico!(M₃,-7.0,n, color = :blue4)

#De la expresión dada se puede notar que se tiene un único punto fijo en x = 4 al cual convergen todas 
#las órbitas
```

```julia
#c)
M₄(x) = x - x^2
n = 20
analisis_grafico(M₄,-0.19, 3,-0.4:1/60:1.3, (-0.42,0.25))
analisis_grafico!(M₄,1.2, 3)
analisis_grafico!(M₄,0.6,n, color = :red)
analisis_grafico!(M₄, 1.05,3 , color = :brown)
analisis_grafico!(M₄, 1.0,n, color = :gold)

#De la expresion de M₄ se puede notar que hay dos puntos fijos, en x = 1 y x = 0
#Las órbitas que inician en el intervalo [0, 1] convergen a cero
#Las órbitas que inician en el intervalo (∞, 0)U(1, ∞) divergen a -∞
```

## Ejercicio 2

--(a) Consideren el mapeo $F(x) = x^2-2$ definido en $-2 \leq x \leq 2$. A partir de una condición al azar, construyan una órbita muy larga, por ejemplo, de $20\,000$ iterados o más. Obtengan el histograma de frecuencias (normalizado) que la órbita visita.

(b) Repitan el ejercicio anterior para el mapeo $G(x) = 2x\mod 1$, definido en el intervalo $x\in[0,1]$.

(c) ¿Qué conclusión podemos sacar de los histogramas para ambos mapeos?

```julia
using Statistics;
```

```julia
F(x) = x^2 - 2
x0 = 1*rand()
its, its_x, its_y = itera_mapeo(F, x0, 20000);
μ_its = mean(its)
σ_its = std(its)
its_normalized = (its.-μ_its)/σ_its;
histogram(its_normalized, label = false, xaxis = ("Normalized Iterations"), yaxis = ("Frequency"), title="F(x)=x²-2" )
```

```julia
G(x) = mod(2*x,1)
x0 = rand()
its, its_x, its_y = itera_mapeo(G, x0, 2000);
μ_its = mean(its)
σ_its = std(its)
its_normalized = (its.-μ_its)/σ_its;
histogram(its_normalized, label = false, xaxis = ("Normalized Iterations"), yaxis = ("Frequency"), title = "G(x)=2x mod 1")
```

## Ejercicio 3

(a) Usando lo que hicieron en la Tarea 1, incluyan lo que desarrollaron para los números `Dual`es en un módulo `NumDual` de Julia ([ver la documentación aquí](https://docs.julialang.org/en/v1.3/manual/modules/)). En particular, el módulo debe exportar el tipo `Dual` y la función `var_dual`, al menos. El archivo con el módulo lo deben incluir en un archivo ".jl" en su propio directorio de tareas. Carguen el módulo en este notebook, usando

```julia
include("NumDual.jl")
using .NumDual
```

(b) Escriban una función que implemente el método de Newton para funciones en una dimensión. La derivada que se requiere debe ser calculada a través de los números duales. Obtengan un cero de $f(x) = x^3 - 8$, como test de que la implementación es correcta.

```julia
function newton(f::Function, x0::T ; max_iter = 100) where {T<:Real}
    k = 0
    x0 = var_dual(x0)
    x = 0.0
    while k <= max_iter
        x = x0.x -  f(x0).x/f(x0).x′
        if abs(x-x0.x) ≈ 0.00001
            break
        end
        k += 1
        x0 = var_dual(x)
    end
    return x
end
```

```julia
#Para probar esta función, usaré que la función f(x) = x³- 8 tiene un único cero en x = 2.
f(x) = x^3 - 8
@assert newton(f, 5) == 2
```

(c) Encuentren los puntos fijos del mapeo $F(x) = x^2 - 1.1$ usando la función que implementaron para el método de Newton.

```julia
F(x) = x^2-1.1
#Es fácil notar de la expresión que ambos puntos fijos están cerca de 1 y -1, respectivamente:
println("x1 = ", newton(F,1))
println("x2 = ", newton(F,-1))
```

(d) Encuentren las puntos *de periodo 2* para el mapeo $F(x) = x^2 - 1.1$ usando la función que implementaron para el método de Newton.

```julia
#De periódo dos significa que se debe iterar dos veces, por lo que defino a la función G como la composición
# de la función F consigo misma - x 
G(x) = F(F(x)) - x
fix0 = newton(G,-1)  #busco el primer punto fijo cerca de -1
x1 = F(fix0)
x2 = F(x1)
#x0 debe ser tal que x2 = x0
@assert x2 == fix0  #Para asegurarme que funciona bien

#Defino la siguiente función para encontrar los puntos fijos de periódo 2:
function per2(F::Function; r = -100:1:100)
    G(x) = F(F(x)) - x
    x0 = collect(r)
    fix = []
    for x in x0
        x1 = newton(G,x)
        push!(fix,x1)
    end
    fix = intersect(fix,fix)
    return fix
end

n = 2
fix = per2(F)

println(fix)
analisis_grafico(F,fix[1], n,-1.2:0.01:1.75,(-1.2,1.8))
analisis_grafico!(F,fix[2], n, color = :red)
analisis_grafico!(F,fix[3], n, color = :Blue4)
analisis_grafico!(F,fix[4], n, color = :green1)

analisis_grafico!(F,fix[1]+0.1, n, color = :grey)
```

(e) Usen números duales para mostrar que los puntos de periodo 2 para el mapeo $F(x) = x^2 -1$ son linealmente estables (atractivos).

```julia
#Primero, encotremos los puntos de periódo 2
F(x) = x^2 - 1
fijos_2 = per2(F, r = -1:1:1)
println("Dos puntos de periodo 2 son: ", fijos_2)

fix0 = var_dual(fijos_2[1])
fix1 = var_dual(fijos_2[2])
#fix2 = var_dual(fijos_2[3])

##Probar que los puntos sean atractivos equivale a probar que la derivada de F²(x) sea igual a 0
#En terminos de duales, la segunda entrada de la función F² evaluada en el punto debe ser cero
@assert F(F(fix0)).x′ == 0.0
@assert F(F(fix1)).x′ == 0.0
println("Los puntos fijos son estables")
```


## Ejercicio 4

(a) El método de Newton es iterativo, y en ese sentido se puede considerar como un mapeo dado por
\begin{equation}
z_{n+1} = N(z_n) = z_n - \frac{f(z_n)}{f'(z_n)}.
\end{equation}
Vamos a considerar la función $f(z) = z^3-1$, e iteraciones del mapeo $N(z)$, con $z\in\mathbb{C}$. Es claro que los ceros de $f(z)$, es decir, las $z^*$ tales que $f(z^*)=0$
tienen la propiedad de que $N(z^*)=z_*$. En este caso concreto los ceros los podemos escribir como $z^*_r = \exp(i 2\pi r/3)$, con $r=0, 1, 2$.

La idea es considerar *muchas* condiciones iniciales $z_0\in[-1,1]\times[-1,1]$, y para cada condición inicial iteraremos muchas veces el mapeo, por ejemplo, $n=10000$ veces. La idea es asignarle a cada condición inicial un color (azul, verde o rojo) según el punto al que converja, o al punto al que más se acerque $z_n$. Dibujen el mapa de colores que se obtiene.

(b) En el mismo espíritu que en el inciso (a), iteren muchas condiciones iniciales para el mapeo
\begin{equation}
z_{n+1} = z_n - a\frac{f(z_n)}{f'(z_n)},
\end{equation}
para la misma función $f(z)$, con $a=2$.

*Nota:* Conviene guardar tres vectores (de condiciones iniciales), y a cada uno se le asignará un color. Para graficar, dado que estamos en los complejos, se graficará la parte real y la parte imaginaria de cada condición inicial.

```julia
```

## Ejercicio 5

Consideremos ahora el triángulo definido por los tres puntos $A=(1, 0)$, $B=(\cos(7\pi/6), \sin(7\pi/6))$ y $C=(\cos(11\pi/6), \sin(11\pi/6))$, y *cualquier* otro punto $X_0$ en $[-1,1]\times[-1,1]$. Consideraremos además un dado (no cargado) que usaremos para generar números aleatorios del 1 al 6 (con `rand(1:6)`).

(a) Definan una regla, la que quieran, que asigne dos salidas distintas del dado (por ejemplo, 1 y 5) a cada uno de los tres vértices del triángulo.

(b) A partir de un punto $X$, definan el mapeo que, para cada tiro del dado $d$, hace que el punto $X$ sea mapeado al punto medio de $X$ y el vértice del triángulo asignado en (a).

(c) Obtengan *el atractor* del mapeo para una sola condición inicial, esto es, iteren muchísimas veces el mapeo ($n=100000$) y pinten la secuencia de los iterados.

(d) ¿Qué pasa si empiezan con otras condiciones iniciales, incluso fuera de $[-1,1]\times[-1,1]$?

```julia
```

## Ejercicio 6

Vamos a considerar el siguiente mapeo lineal, en dos dimensiones, dado por

\begin{equation}
B(x_{n+1}, y_{n+1} ) =
\left( \begin{array}{c} x_{n+1} \\ y_{n+1} \end{array} \right) =
\left(\begin{array}{cc} a & b\\ c & d \end{array}\right)
\left( \begin{array}{c} x_{n} \\ y_{n} \end{array} \right) +
\left( \begin{array}{c} 0 \\ f \end{array} \right).
\end{equation}

Los coeficientes que aparecen en el mapeo se eligirán de manera aleatoria, con
probabilidad $p$, de acuerdo con la siguiente tabla:

|     p     |     a     |     b     |     c     |     d     |     f     |
|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|
|   0.01    |     0     |     0     |     0     |    0.16   |   0    |
|   0.85    |  0.85     |     0.04  |   -0.04   |    0.85   |   1.6     |
|   0.07    |  0.2      |    -0.26  |    0.23   |    0.22   |   1.6     |
|   0.07    | -0.15     |     0.28  |    0.26   |    0.24   |   0.44    |

Dibujen (en verde, usando `markerstrokecolor=:green`) el atractor del mapeo.

```julia
```
